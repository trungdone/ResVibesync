import re
import unicodedata
import difflib
from utils.gemini_api import ask_gemini
from services.artist_service import ArtistService
from services.song_service import SongService
from database.repositories.artist_repository import ArtistRepository
from database.repositories.song_repository import SongRepository
from services.album_service import AlbumService


# ======== Chu·∫©n h√≥a vƒÉn b·∫£n ==========
def normalize_text(text: str) -> str:
    text = text.lower()
    text = unicodedata.normalize('NFD', text)
    text = re.sub(r'[\u0300-\u036f]', '', text)  # b·ªè d·∫•u ti·∫øng Vi·ªát
    text = re.sub(r'[^\w\s]', '', text)          # b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
    return text.strip()

# ======== Ph√°t hi·ªán ng√¥n ng·ªØ ==========
def detect_language(text: str) -> str:
    return "en" if re.search(r'[a-zA-Z]', text) and not re.search(r'[√†-·ªπ√Ä-·ª∏]', text) else "vi"


def find_best_match(query: str, candidates: list[str]) -> str:
    query_norm = normalize_text(query)
    candidates_norm = [normalize_text(c) for c in candidates]
    matches = difflib.get_close_matches(query_norm, candidates_norm, n=1, cutoff=0.6)
    if matches:
        matched_index = candidates_norm.index(matches[0])
        return candidates[matched_index]  # tr·∫£ v·ªÅ t√™n g·ªëc ban ƒë·∫ßu
    return None

def search_artist(query: str, all_artists: list[str]):
    best_match = find_best_match(query, all_artists)
    if best_match:
        print(f"T√¨m th·∫•y ngh·ªá sƒ© g·∫ßn ƒë√∫ng: {best_match}")
        # L√∫c n√†y b·∫°n c√≥ th·ªÉ truy v·∫•n DB b·∫±ng best_match
        return best_match
    else:
        print("Kh√¥ng t√¨m th·∫•y ngh·ªá sƒ© ph√π h·ª£p.")
        return None


# ======== Kh·ªüi t·∫°o service ==========
artist_repo = ArtistRepository()
song_repo = SongRepository()
artist_service = ArtistService()
song_service = SongService(song_repo, artist_repo)

artist_service = ArtistService()

def get_all_artists_simple():
    return artist_service.get_all_artists_simple()


# ======== L·∫•y d·ªØ li·ªáu t·ª´ MongoDB ==========
try:
    ARTISTS_DATA = artist_service.get_all_artists_simple()
except Exception:
    ARTISTS_DATA = []

try:
    SONGS_DATA = song_service.get_all_songs_simple()
except Exception:
    SONGS_DATA = []

# ======== T·∫°o danh s√°ch t√¨m ki·∫øm m·ªÅm ==========
ARTIST_ENTRIES = [
    {
        "name": artist["name"],
        "aliases": artist.get("aliases", []),
        "bio": artist.get("bio", ""),
        "url": f"http://localhost:3000/artist/{artist['_id']}",
        "keywords": [normalize_text(artist["name"])] + [normalize_text(alias) for alias in artist.get("aliases", [])],
    }
    for artist in ARTISTS_DATA
]

SONG_ENTRIES = [
    {
        "title": song["title"],
        "artist": song.get("artist", ""),
        "artistId": str(song.get("artistId", "")),
        "releaseYear": song.get("releaseYear", ""),
        "url": f"http://localhost:3000/song/{song['song_id']}",
        "keywords": [normalize_text(song["title"])],
    }
    for song in SONGS_DATA
]

# ======== C√¢u h·ªèi ƒë·ªãnh nghƒ©a s·∫µn ==========
CUSTOM_RESPONSES = {
    "creator": {
        "questions": [
            "ai t·∫°o ra trang web n√†y", "ai ph√°t tri·ªÉn trang web n√†y",
            "ng∆∞·ªùi l√†m ra trang web n√†y l√† ai", "ai l√†m website n√†y",
            "ai l√† l·∫≠p tr√¨nh vi√™n", "developer l√† ai", "dev l√† ai"
        ],
        "answer_vi": "üßë‚Äçüíª Website n√†y ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi ƒë·ªôi ng≈© VibeSync ‚Äì ƒëam m√™ √¢m nh·∫°c v√† c√¥ng ngh·ªá.",
        "answer_en": "üßë‚Äçüíª This website was developed by the VibeSync team ‚Äì passionate about music and technology.",
    },
    "purpose": {
        "questions": [
            "trang web n√†y d√πng ƒë·ªÉ l√†m g√¨", "m·ª•c ƒë√≠ch c·ªßa trang web n√†y l√† g√¨",
            "website n√†y d√πng ƒë·ªÉ l√†m g√¨", "t√¥i v√†o trang web n√†y ƒë·ªÉ l√†m g√¨",
            "ch·ª©c nƒÉng c·ªßa trang web", "trang web ho·∫°t ƒë·ªông th·∫ø n√†o"
        ],
        "answer_vi": "üéß VibeSync l√† n·ªÅn t·∫£ng nghe nh·∫°c th√¥ng minh, n∆°i b·∫°n c√≥ th·ªÉ t√¨m ki·∫øm, nghe v√† kh√°m ph√° playlist theo t√¢m tr·∫°ng.",
        "answer_en": "üéß VibeSync is a smart music platform where you can search, listen, and explore playlists based on your mood.",
    },
    "register": {
        "questions": [
            "l√†m sao ƒë·ªÉ ƒëƒÉng k√Ω t√†i kho·∫£n", "c√°ch ƒëƒÉng k√Ω t√†i kho·∫£n", "t√¥i mu·ªën t·∫°o t√†i kho·∫£n",
            "ƒëƒÉng k√Ω nh∆∞ th·∫ø n√†o", "ƒëƒÉng k√≠ nh∆∞ th·∫ø n√†o", "ƒëƒÉng k√≠ th·∫ø n√†o",
            "h∆∞·ªõng d·∫´n ƒëƒÉng k√Ω", "ƒëƒÉng k√Ω ·ªü ƒë√¢u"
        ],
        "answer_vi": "üîê B·∫°n c√≥ th·ªÉ t·∫°o t√†i kho·∫£n b·∫±ng c√°ch nh·∫•n v√†o n√∫t 'ƒêƒÉng k√Ω' ·ªü g√≥c tr√™n c√πng b√™n ph·∫£i, sau ƒë√≥ ƒëi·ªÅn th√¥ng tin.",
        "answer_en": "üîê You can create an account by clicking the 'Sign Up' button at the top right and filling in your details.",
    },
    "free_music": {
        "questions": [
            "t√¥i c√≥ th·ªÉ nghe nh·∫°c mi·ªÖn ph√≠ kh√¥ng", "nghe nh·∫°c c√≥ m·∫•t ph√≠ kh√¥ng",
            "website c√≥ mi·ªÖn ph√≠ kh√¥ng", "nghe nh·∫°c free kh√¥ng",
            "nghe nh·∫°c kh√¥ng t·ªën ti·ªÅn kh√¥ng", "c√≥ tr·∫£ ph√≠ kh√¥ng"
        ],
        "answer_vi": "‚úÖ Ho√†n to√†n c√≥ th·ªÉ! T·∫•t c·∫£ playlist c∆° b·∫£n ƒë·ªÅu mi·ªÖn ph√≠, kh√¥ng c·∫ßn tr·∫£ ph√≠.",
        "answer_en": "‚úÖ Yes! All basic playlists are free, no subscription required.",
    },
}

# ========== H√ÄM X·ª¨ L√ù CH√çNH ==========

async def handle_user_question(prompt: str) -> str:
    norm_prompt = normalize_text(prompt)
    language = detect_language(prompt)

    # 1. Tr·∫£ l·ªùi nhanh theo c√¢u h·ªèi ƒë·ªãnh nghƒ©a
    for group in CUSTOM_RESPONSES.values():
        for question in group["questions"]:
            if normalize_text(question) in norm_prompt:
                return group["answer_vi"] if language == "vi" else group["answer_en"]

    # 2. Nh·∫Øc ng∆∞·ªùi d√πng n·∫øu kh√¥ng r√µ
    MUSIC_KEYWORDS = [normalize_text(w) for w in ["b√†i h√°t", "ca sƒ©", "nh·∫°c", "ngh·ªá sƒ©", "song", "artist", "music"]]
    if len(norm_prompt.split()) <= 5 and not any(word in norm_prompt for word in MUSIC_KEYWORDS):
        return (
            "‚ùó C√¢u h·ªèi c·ªßa b·∫°n ch∆∞a r√µ r√†ng. Vui l√≤ng n√≥i r√µ b·∫°n ƒëang t√¨m *b√†i h√°t*, *ca sƒ©*, ho·∫∑c th·ªÉ lo·∫°i nh·∫°c n√†o üéµ.\n"
            "V√≠ d·ª•: *'b√†i h√°t Y√™u M·ªôt Ng∆∞·ªùi C√≥ L·∫Ω'* ho·∫∑c *'ca sƒ© S∆°n T√πng M-TP'*."
            if language == "vi" else
            "‚ùó Your question is unclear. Please specify whether you're looking for a *song*, *artist*, or *music genre* üéµ.\n"
            "Example: *'song Love Someone Like You'* or *'artist Taylor Swift'*."
        )
    
    

    # 3. Enrich prompt n·∫øu qu√° ng·∫Øn
    enriched_prompt = prompt
    if len(prompt.split()) == 1 and " " not in prompt and not any(c in prompt for c in "?!"):
        enriched_prompt = f"b√†i h√°t {prompt}" if language == "vi" else f"song {prompt}"

    # 4. So kh·ªõp g·∫ßn ƒë√∫ng
    def get_similarity(a, b):
        if b in a or a in b:
            return 1.0
        return difflib.SequenceMatcher(None, a, b).ratio()

    best_entry = None
    best_score = 0.0

    for entry in ARTIST_ENTRIES + SONG_ENTRIES:
        for keyword in entry["keywords"]:
            score = get_similarity(norm_prompt, keyword)
            if score > best_score:
                best_score = score
                best_entry = entry

    # 5. N·∫øu kh·ªõp d·ªØ li·ªáu ngh·ªá sƒ© ho·∫∑c b√†i h√°t
    if best_entry and best_score >= 0.6:
        name = best_entry.get("name") or best_entry.get("title")
        extra_info = ""
        artist_name = ""
        artist_bio = ""
        release_year = ""

        if "bio" in best_entry:  # Entry l√† ngh·ªá sƒ©
            artist_name = best_entry["name"]
            artist_bio = best_entry.get("bio", "").strip()

            extra_info = (
                f"Gi·ªõi thi·ªáu v·ªÅ ngh·ªá sƒ© {artist_name}.\nƒê√¢y l√† m√¥ t·∫£ c·ªßa h·ªç: {artist_bio}"
                if language == "vi" and artist_bio else
                f"Gi·ªõi thi·ªáu v·ªÅ ngh·ªá sƒ© {artist_name}."
                if language == "vi" else
                f"Introduce the artist {artist_name}.\nHere is their bio: {artist_bio}"
                if artist_bio else
                f"Introduce the artist {artist_name}."
            )

        elif "title" in best_entry:  # Entry l√† b√†i h√°t
            song_title = best_entry.get("title", "b√†i h√°t kh√¥ng r√µ")
            artist_name = best_entry.get("artist", "").strip()
            artist_bio = ""
            release_year = best_entry.get("releaseYear", "")

            for a in ARTISTS_DATA:
                if a["name"].lower() == artist_name.lower() or str(a["artist_id"]) == best_entry.get("artistId", ""):
                    artist_bio = a.get("bio", "").strip()
                    break

            if artist_name:
                if artist_bio:
                    extra_info = (
                        f"H√£y gi·ªõi thi·ªáu b√†i h√°t '{song_title}' c·ªßa ca sƒ© {artist_name} ph√°t h√†nh nƒÉm {release_year}.\n"
                        f"Th√¥ng tin ngh·ªá sƒ©: {artist_bio}"
                        if language == "vi" else
                        f"Describe in detail the song '{song_title}' by artist {artist_name}, released in {release_year}.\n"
                        f"Artist bio: {artist_bio}"
                    )
                else:
                    extra_info = (
                        f"H√£y gi·ªõi thi·ªáu b√†i h√°t '{song_title}' c·ªßa ca sƒ© {artist_name} ph√°t h√†nh nƒÉm {release_year}."
                        if language == "vi" else
                        f"Describe in detail the song '{song_title}' by artist {artist_name}, released in {release_year}."
                    )
            else:
                extra_info = (
                    f"H√£y m√¥ t·∫£ b√†i h√°t '{song_title}'."
                    if language == "vi" else
                    f"Describe the song '{song_title}'."
                )

        enriched_prompt = extra_info
        reply = await ask_gemini(enriched_prompt)
        reply += f"\n\nüëâ B·∫°n c√≥ th·ªÉ xem th√™m v·ªÅ: [{name}]({best_entry['url']})"
        return reply

    # 6. N·∫øu kh√¥ng kh·ªõp g√¨ ‚Üí g·ª≠i prompt g·ªëc
    reply = await ask_gemini(enriched_prompt)
    reply += (
        "\n\n‚ùó Website c·ªßa ch√∫ng t√¥i chuy√™n v·ªÅ √¢m nh·∫°c. "
        "Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi li√™n quan ƒë·∫øn playlist, ca sƒ©, th·ªÉ lo·∫°i nh·∫°c ho·∫∑c b√†i h√°t b·∫°n mu·ªën nghe üéµ."
        if language == "vi" else
        "\n\n‚ùó Our website focuses on music. Please ask questions about playlists, artists, genres, or songs you want to hear üéµ."
    )
    return reply


